const os = require('os');
const { execSync } = require('child_process');

class GitHubAnalytics {
  constructor() {
    this.repo = 'sjuberrafik-clgx/testgenie';
    this.apiUrl = 'https://api.github.com';
    this.enabled = true;
    this.dataRetentionYears = 7; // Keep data for 7 years (permanent business storage)
    this.archiveAfterDays = 365; // Archive to separate issues after 1 year
  }

  async track(data) {
    if (!this.enabled) return;

    try {
      const userData = this.getUserData();
      const timestamp = new Date().toISOString();
      const eventId = this.generateEventId(userData.username, data.action, timestamp);
      
      const issueBody = `## ğŸ§â€â™€ï¸ TestGenie Analytics Event [${eventId}]

### ğŸ“Š Event Details
**User**: ${userData.username}
**Email**: ${userData.email}
**Hostname**: ${userData.hostname}
**Action**: ${data.action}
**Timestamp**: ${timestamp}
**Event ID**: ${eventId}

### ğŸ–¥ï¸ System Information  
**Version**: ${data.version || require('../package.json').version}
**Platform**: ${os.platform()} ${os.release()}
**Architecture**: ${os.arch()}
**Node Version**: ${process.version}
**Memory**: ${Math.round(os.totalmem() / 1024 / 1024 / 1024)}GB

### ğŸ“‹ Command Details
**Install Location**: ${data.installLocation || process.cwd()}
**Command**: ${data.command || 'unknown'}
**Success**: ${data.success !== false ? 'âœ… true' : 'âŒ false'}
**Duration**: ${data.duration ? `${data.duration}ms` : 'unknown'}
**Options**: ${JSON.stringify(data.options || {})}

### ğŸ—„ï¸ Data Retention Policy
**Retention Period**: ${this.dataRetentionYears} years (until ${this.getRetentionDate()})
**Archive Date**: ${this.getArchiveDate()}
**Storage Type**: Permanent Business Record
**Compliance**: CoreLogic Data Retention Standards

---
*Auto-generated by TestGenie CLI v${data.version || require('../package.json').version}*
*Event logged on ${timestamp} for permanent business analytics*`;

      const issue = {
        title: `ğŸ“Š Analytics: ${data.action} by ${userData.username} [${eventId}]`,
        body: issueBody,
        labels: [
          'analytics', 
          data.action, 
          os.platform(), 
          'auto-generated',
          `year-${new Date().getFullYear()}`,
          'permanent-storage',
          userData.hostname.includes('clgx') ? 'enterprise' : 'external'
        ]
      };

      // Submit to GitHub Issues API
      const response = await fetch(`${this.apiUrl}/repos/${this.repo}/issues`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'TestGenie-CLI',
          'Accept': 'application/vnd.github.v3+json'
        },
        body: JSON.stringify(issue)
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`ğŸ“Š Analytics tracked: ${data.action} [${eventId}] â†’ Issue #${result.number}`);
        
        // Periodic data archival check (5% chance to trigger)
        if (Math.random() < 0.05) {
          this.scheduleDataArchival();
        }
      } else {
        console.log(`ğŸ“Š Analytics: GitHub API responded with ${response.status}`);
      }
    } catch (error) {
      // Silent fail for analytics - never break functionality
      console.log(`ğŸ“Š Analytics: Unable to connect (${error.message})`);
    }
  }

  generateEventId(username, action, timestamp) {
    const crypto = require('crypto');
    const hash = crypto.createHash('md5');
    hash.update(`${username}-${action}-${timestamp}`);
    return hash.digest('hex').substring(0, 8);
  }

  getRetentionDate() {
    const retentionDate = new Date();
    retentionDate.setFullYear(retentionDate.getFullYear() + this.dataRetentionYears);
    return retentionDate.toISOString().split('T')[0];
  }

  getArchiveDate() {
    const archiveDate = new Date();
    archiveDate.setDate(archiveDate.getDate() + this.archiveAfterDays);
    return archiveDate.toISOString().split('T')[0];
  }

  async scheduleDataArchival() {
    // Log archival check - in production this would trigger a GitHub Action
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.archiveAfterDays);
    console.log(`ğŸ“¦ Analytics: Checking for data to archive (older than ${cutoffDate.toISOString().split('T')[0]})`);
  }

  getUserData() {
    let username = 'unknown';
    let email = 'unknown';
    
    try {
      // Try to get username from system
      username = os.userInfo().username;
    } catch (e) {
      // Fallback methods
      try {
        username = process.env.USERNAME || process.env.USER || 'unknown';
      } catch (e) {
        username = 'unknown';
      }
    }

    try {
      // Try to get email from git config
      email = execSync('git config --global user.email', { encoding: 'utf8' }).trim();
    } catch (e) {
      email = 'unknown';
    }

    return {
      username,
      email,
      hostname: os.hostname()
    };
  }

  async trackInstallStart(data = {}) {
    await this.track({
      action: 'install_start',
      ...data
    });
  }

  async trackInstallSuccess(data = {}) {
    await this.track({
      action: 'install_success',
      ...data
    });
  }

  async trackInstallError(error, data = {}) {
    await this.track({
      action: 'install_error',
      error: error.message,
      success: false,
      ...data
    });
  }

  async trackCommand(command, data = {}) {
    await this.track({
      action: 'command',
      command: command,
      ...data
    });
  }
}

module.exports = GitHubAnalytics;